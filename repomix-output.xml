This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.husky/
  commit-msg
  pre-commit
src/
  biometrics/
    application/
      use-cases/
        GetUnifiedSessionReport.ts
        RegisterPresenceMinute.ts
        SyncDailyBiometrics.ts
    domain/
      models/
        BiometricMinute.ts
        PresenceInterval.ts
    infrastructure/
      database/
        SupabaseSessionMetricsRepository.ts
      endpoints/
        __tests__/
          getSessionReport.test.ts
        getSessionReport.ts
        presenceMinute.ts
        syncDailyBiometrics.ts
  clinical-intelligence/
    application/
      __tests__/
        PredictHealthAnomalies.spec.ts
      DropoutAnalysisService.ts
    domain/
      interfaces/
        DropoutRepository.ts
      models/
        DropoutRisk.ts
      ClinicalError.ts
    infrastructure/
      __tests__/
        predictDropout.test.ts
      database/
        __tests__/
          SupabaseDropoutRepository.test.ts
        SupabaseDropoutRepository.ts
      endpoints/
        __tests__/
          predictDropout.test.ts
        predictDropout.ts
  common/
    domain/
      model/
        UserParameters.ts
    infrastructure/
      database/
        initTestDatabase.ts
        supabaseClient.ts
        supabaseTypes.ts
      endpoints/
        routes.ts
      server/
        index.ts
        securityLogger.ts
        serverBuild.ts
  identity/
    domain/
      interfaces/
        repositories/
          UserRepository.ts
    infrastructure/
      database/
        repositories/
          SupabaseUserRepository.ts
      http/
        authenticate.ts
        verifyUser.ts
  messaging/
    application/
      __tests__/
        SendToPatient.spec.ts
        SendWeeklyStats.spec.ts
      ManageNotifications.ts
      SendToPatient.ts
      SendWeeklyStats.ts
    domain/
      interfaces/
        MailRepository.ts
        NotificationRepository.ts
        PatientContactRepository.ts
        StatsRepository.ts
      MessagingError.ts
    infrastructure/
      __tests__/
        e2e/
          messagingFlow.e2e.ts
      database/
        __tests__/
          SupabasePatientContactRepository.test.ts
          SupabaseStatsRepository.test.ts
        SupabaseNotificationRepository.ts
        SupabasePatientContactRepository.ts
        SupabaseStatsRepository.ts
      endpoints/
        __tests__/
          sendToPatient.test.ts
          sendWeeklyStats.test.ts
        patientNotifications.ts
        sendToPatient.ts
        sendWeeklyStats.ts
      gmail/
        GmailApiMailRepository.ts
      images/
        HtmlImageGenerator.ts
      worker/
        MessagingWorker.ts
  types/
    fastify.d.ts
supabase/
  .temp/
    cli-latest
  migrations/
    20260115171404_secure_unrestricted_tables.sql
.env.test.example
.gitignore
.prettierrc
Dockerfile
eslint.config.cjs
jest.config.js
package.json
tsconfig.build.json
tsconfig.jest.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".husky/commit-msg">
#!/usr/bin/env sh
npx --no -- commitlint --edit "$1"
</file>

<file path=".husky/pre-commit">
#!/usr/bin/env sh
npx lint-staged
</file>

<file path="src/biometrics/application/use-cases/GetUnifiedSessionReport.ts">
import { SupabaseSessionMetricsRepository } from '../../infrastructure/database/SupabaseSessionMetricsRepository';

export class GetUnifiedSessionReport {
    constructor(private readonly repository: SupabaseSessionMetricsRepository) {}

    async execute(patientId: number, sessionId: string) {
        const { data: session } = await this.repository.getSessionData(patientId, sessionId);
        if (!session) throw new Error('SESSION_NOT_FOUND');

        const { data: intervals } = await this.repository.getContextIntervals(patientId, sessionId);
        const sessionIntervals = intervals?.filter(i => i.session_id === sessionId) || [];
        if (sessionIntervals.length === 0) throw new Error('NO_INTERVALS_FOUND');

        const firstStart = sessionIntervals[0].start_minute_utc;
        const lastEnd = sessionIntervals[sessionIntervals.length - 1].end_minute_utc;

        const preInt = intervals?.filter(i => i.context_type === 'dashboard' && i.end_minute_utc <= firstStart).pop();
        const postInt = intervals?.find(i => i.context_type === 'dashboard' && i.start_minute_utc >= lastEnd);

        const biometrics = await this.repository.getBiometricData(
            patientId,
            preInt?.start_minute_utc || firstStart,
            postInt?.end_minute_utc || lastEnd
        );

        const getStats = (data: any[], key: string, start?: string, end?: string) => {
            if (!start || !end) return { avg: 0, max: 0, min: 0 };
            const filtered = data.filter(b => b.timestamp_iso >= start && b.timestamp_iso <= end);
            const values = filtered.map(d => d[key]).filter(v => v !== null) as number[];
            if (values.length === 0) return { avg: 0, max: 0, min: 0 };
            return {
                avg: parseFloat((values.reduce((a, b) => a + b, 0) / values.length).toFixed(2)),
                max: Math.max(...values),
                min: Math.min(...values)
            };
        };

        const metrics: any = {};
        const keys = ['eda_scl_usiemens', 'prv_rmssd_ms', 'pulse_rate_bpm', 'temperature_celsius', 'spo2_percentage'];

        keys.forEach(k => {
            metrics[k] = {
                pre: getStats(biometrics.data || [], k, preInt?.start_minute_utc, preInt?.end_minute_utc),
                session: getStats(biometrics.data || [], k, firstStart, lastEnd),
                post: getStats(biometrics.data || [], k, postInt?.start_minute_utc, postInt?.end_minute_utc)
            };
        });

        const subjectiveScore = ((session.post_evaluation || 0) - (session.pre_evaluation || 0)) * 10 * 0.4;

        const calcObj = (m: any, w: number, inv = false) => {
            if (m.pre.avg === 0) return 0;
            const dSes = inv ? (m.pre.avg - m.session.avg) / m.pre.avg : (m.session.avg - m.pre.avg) / m.pre.avg;
            const dPost = inv ? (m.pre.avg - m.post.avg) / m.pre.avg : (m.post.avg - m.pre.avg) / m.pre.avg;
            return Math.min(Math.max(0, dSes * 0.7 + dPost * 0.3) * 100, 100) * w;
        };

        const objectiveScore =
            calcObj(metrics.eda_scl_usiemens, 0.20) + calcObj(metrics.prv_rmssd_ms, 0.15, true) +
            calcObj(metrics.pulse_rate_bpm, 0.10) + calcObj(metrics.temperature_celsius, 0.10) +
            calcObj(metrics.spo2_percentage, 0.05, true);

        return {
            state: session.state,
            attempts: sessionIntervals.length,
            total_duration_minutes: Math.round((new Date(lastEnd).getTime() - new Date(firstStart).getTime()) / 60000),
            final_score_percentage: parseFloat((subjectiveScore + objectiveScore).toFixed(2)),
            phases_detected: {
                pre: { start: preInt?.start_minute_utc || null, end: preInt?.end_minute_utc || null },
                session: { start: firstStart, end: lastEnd },
                post: { start: postInt?.start_minute_utc || null, end: postInt?.end_minute_utc || null }
            },
            subjective_analysis: {
                pre_evaluation: session.pre_evaluation,
                post_evaluation: session.post_evaluation,
                delta: (session.post_evaluation || 0) - (session.pre_evaluation || 0)
            },
            objective_metrics: metrics
        };
    }
}
</file>

<file path="src/biometrics/application/use-cases/RegisterPresenceMinute.ts">
import { supabaseClient } from '@common/infrastructure/database/supabaseClient';
import { ContextType } from '../../domain/models/PresenceInterval';

type Params = {
    patientId: string;
    minuteTsUtc: string;
    contextType: ContextType;
    sessionId: string | null;
};

export class RegisterPresenceMinute {
    private isUuid(value: string) {
        return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
    }

    private validate(params: Params, date: Date) {
        if (!params.patientId) throw new Error('Unauthorized');
        if (Number.isNaN(date.getTime())) throw new Error('minuteTsUtc must be a valid ISO date');
        if (date.getUTCSeconds() !== 0 || date.getUTCMilliseconds() !== 0) {
            throw new Error('minuteTsUtc must be rounded to the minute');
        }
        if (params.contextType !== 'dashboard' && params.contextType !== 'session') {
            throw new Error('Invalid contextType');
        }
        if (params.contextType === 'session' && (!params.sessionId || !this.isUuid(params.sessionId))) {
            throw new Error('sessionId must be a valid UUID for session context');
        }
        if (params.contextType === 'dashboard' && params.sessionId !== null) {
            throw new Error('sessionId must be null for dashboard context');
        }
    }

    async execute(params: Params) {
        const now = new Date();
        now.setUTCSeconds(0, 0);

        const minute = params.minuteTsUtc ? new Date(params.minuteTsUtc) : now;
        this.validate(params, minute);

        const endMinute = new Date(minute.getTime() + 60_000);

        const { data: lastRows, error: lastErr } = await (supabaseClient as any)
            .from('context_intervals')
            .select('id, context_type, session_id, end_minute_utc')
            .eq('patient_id', params.patientId)
            .order('start_minute_utc', { ascending: false })
            .limit(1);

        if (lastErr) throw new Error(lastErr.message);

        const last = lastRows?.[0] as any;
        const sameContext = !!last &&
            last.context_type === params.contextType &&
            (last.session_id ?? null) === params.sessionId;

        if (sameContext) {
            const lastEnd = new Date(last.end_minute_utc);
            if (endMinute > lastEnd) {
                const { data, error } = await (supabaseClient as any)
                    .from('context_intervals')
                    .update({ end_minute_utc: endMinute.toISOString() })
                    .eq('id', last.id)
                    .select().single();
                if (error) throw new Error(error.message);
                return { data, action: 'extended' };
            }
            return { data: last, action: 'idempotent_no_change' };
        }

        const { data, error } = await (supabaseClient as any)
            .from('context_intervals')
            .insert({
                patient_id: params.patientId,
                context_type: params.contextType,
                session_id: params.sessionId,
                start_minute_utc: minute.toISOString(),
                end_minute_utc: endMinute.toISOString(),
                attempt_no: params.contextType === 'session' ? 1 : null
            })
            .select().single();

        if (error) throw new Error(error.message);
        return { data, action: 'created' };
    }
}
</file>

<file path="src/biometrics/domain/models/BiometricMinute.ts">
export interface BiometricMinute {
    participant_full_id: string;
    device_sn: string | null;
    timestamp_unix_ms: number;
    timestamp_iso: string;
    pulse_rate_bpm: number | null;
    prv_rmssd_ms: number | null;
    respiratory_rate_brpm: number | null;
    eda_scl_usiemens: number | null;
    temperature_celsius: number | null;
    patient_id: string;
}
</file>

<file path="src/biometrics/domain/models/PresenceInterval.ts">
export type ContextType = 'dashboard' | 'session';

export interface PresenceInterval {
    id?: string;
    patientId: string;
    contextType: ContextType;
    sessionId: string | null;
    startMinuteUtc: string;
    endMinuteUtc: string;
    attemptNo?: number | null;
}
</file>

<file path="src/biometrics/infrastructure/database/SupabaseSessionMetricsRepository.ts">
import { SupabaseClient } from '@supabase/supabase-js';
import { Database } from '@src/common/infrastructure/database/supabaseTypes';

export class SupabaseSessionMetricsRepository {
    constructor(private readonly client: SupabaseClient<Database>) {}

    async getSessionData(patientId: number, sessionId: string) {
        return await this.client
            .from('PatientSession')
            .select('state, pre_evaluation, post_evaluation')
            .eq('id', parseInt(sessionId))
            .eq('patient_id', patientId)
            .single();
    }

    async getContextIntervals(patientId: number, sessionId: string) {
        return await this.client
            .from('ContextIntervals')
            .select('*')
            .eq('patient_id', patientId.toString())
            .or(`session_id.eq.${sessionId},context_type.eq.dashboard`)
            .order('start_minute_utc', { ascending: true });
    }

    async getBiometricData(patientId: number, start: string, end: string) {
        return await this.client
            .from('ContextIntervals')
            .select('*')
            .eq('patient_id', patientId.toString())
            .gte('timestamp_iso', start)
            .lte('timestamp_iso', end);
    }
}
</file>

<file path="src/biometrics/infrastructure/endpoints/getSessionReport.ts">
import { FastifyInstance } from 'fastify';
import { GetUnifiedSessionReport } from '../../application/use-cases/GetUnifiedSessionReport';
import { SupabaseSessionMetricsRepository } from '../database/SupabaseSessionMetricsRepository';
import { supabaseClient } from '@src/common/infrastructure/database/supabaseClient';

export default function getSessionReport() {
    return async function (fastify: FastifyInstance) {
        const repo = new SupabaseSessionMetricsRepository(supabaseClient);
        const useCase = new GetUnifiedSessionReport(repo);

        fastify.get('/biometrics/session-report/:patientId/:sessionId', async (request, reply) => {
            const { patientId, sessionId } = request.params as any;
            try {
                const report = await useCase.execute(parseInt(patientId), sessionId);
                return reply.status(200).send({ status: 'success', data: report });
            } catch (e: any) {
                return reply.status(500).send({ status: 'error', message: e.message });
            }
        });
    };
}
</file>

<file path="src/biometrics/infrastructure/endpoints/syncDailyBiometrics.ts">
import { FastifyReply, FastifyRequest } from 'fastify';
import { SyncDailyBiometrics } from '../../application/use-cases/SyncDailyBiometrics';

export default function syncDailyBiometrics() {
    return async function (request: FastifyRequest, reply: FastifyReply) {
        const cronSecret = request.headers['x-health-insight-cron'];
        if (!cronSecret || cronSecret !== process.env.CRON_SECRET_KEY) {
            return reply.status(403).send({ status: 'error', message: 'Unauthorized' });
        }

        const yesterday = new Date();
        yesterday.setUTCDate(yesterday.getUTCDate() - 1);
        const dateStr = yesterday.toISOString().split('T')[0];

        try {
            const useCase = new SyncDailyBiometrics();
            const summary = await useCase.execute(dateStr);

            return reply.status(200).send({
                status: 'success',
                date: dateStr,
                summary // Esto te dirá filesFound y rowsInserted en tu terminal
            });
        } catch (error: any) {
            return reply.status(500).send({ status: 'error', message: error.message });
        }
    };
}
</file>

<file path="src/clinical-intelligence/application/__tests__/PredictHealthAnomalies.spec.ts">
import { DropoutAnalysisService } from '../DropoutAnalysisService';
import { DropoutRepository } from '../../domain/interfaces/DropoutRepository';
import { DropoutRisk } from '../../domain/models/DropoutRisk';

describe('DropoutAnalysisService', () => {
    let service: DropoutAnalysisService;
    let mockRepository: jest.Mocked<DropoutRepository>;

    beforeEach(() => {
        mockRepository = {
            getPatientSessionData: jest.fn()
        };
        service = new DropoutAnalysisService(mockRepository);
        jest.clearAllMocks();
    });

    it('should return NO_DATA code when no patient data is found', async () => {
        mockRepository.getPatientSessionData.mockResolvedValue([]);

        const result = await service.execute();

        // Comprobamos que devuelve el objeto de error esperado
        expect(result).toHaveProperty('type');
    });

    it('should identify a CRITICAL risk for patients with overdue calendars', async () => {
        const pastDate = new Date();
        pastDate.setDate(pastDate.getDate() - 5);

        mockRepository.getPatientSessionData.mockResolvedValue([{
            patientId: 'p1',
            name: 'Test Patient',
            sessionId: 's1',
            assignedDate: pastDate.toISOString(),
            sessionStatus: 'assigned',
            sessionUpdate: null,
            postEval: 0
        }]);

        const result = await service.execute('p1');

        if (Array.isArray(result)) {
            expect(result[0].patientId).toBe('p1');
            expect(result[0].riskScore).toBeGreaterThanOrEqual(50);
            expect(result[0].factors).toContain('Retraso en calendario');
        } else {
            fail('Result should be an array');
        }
    });

    it('should identify dizziness in last session as a risk factor', async () => {
        const futureDate = new Date();
        futureDate.setDate(futureDate.getDate() + 2);

        mockRepository.getPatientSessionData.mockResolvedValue([
            {
                patientId: 'p2',
                name: 'Dizzy Patient',
                sessionId: 's1',
                assignedDate: new Date().toISOString(),
                sessionStatus: 'completed',
                sessionUpdate: null,
                postEval: 9
            },
            {
                patientId: 'p2',
                name: 'Dizzy Patient',
                sessionId: 's2',
                assignedDate: futureDate.toISOString(),
                sessionStatus: 'assigned',
                sessionUpdate: null,
                postEval: 0
            }
        ]);

        const result = await service.execute();

        if (Array.isArray(result)) {
            expect(result[0].factors).toContain('Mareo elevado en ultima sesion');
            expect(result[0].riskScore).toBe(20);
            expect(result[0].status).toBe('LOW');
        } else {
            fail('Result should be an array');
        }
    });

    it('should detect stale in-progress sessions as a significant risk', async () => {
        const oldUpdate = new Date();
        oldUpdate.setHours(oldUpdate.getHours() - 30);

        mockRepository.getPatientSessionData.mockResolvedValue([{
            patientId: 'p3',
            name: 'Stuck Patient',
            sessionId: 's3',
            assignedDate: new Date().toISOString(),
            sessionStatus: 'in_progress',
            sessionUpdate: oldUpdate.toISOString(),
            postEval: 0
        }]);

        const result = await service.execute();

        if (Array.isArray(result)) {
            expect(result[0].riskScore).toBe(35);
            expect(result[0].factors).toContain('In-progress antiguo (>24h)');
        } else {
            fail('Result should be an array');
        }
    });

    it('should sort results by risk score in descending order', async () => {
        mockRepository.getPatientSessionData.mockResolvedValue([
            { patientId: 'low', name: 'Low Risk', sessionId: 's1', assignedDate: new Date().toISOString(), sessionStatus: 'completed', postEval: 0 },
            { patientId: 'high', name: 'High Risk', sessionId: 's2', assignedDate: '2000-01-01', sessionStatus: 'assigned', postEval: 0 }
        ]);

        const result = await service.execute();

        if (Array.isArray(result)) {
            expect(result[0].patientId).toBe('high');
            expect(result[1].patientId).toBe('low');
            expect(result[0].riskScore).toBeGreaterThan(result[1].riskScore);
        } else {
            fail('Result should be an array');
        }
    });
});
</file>

<file path="src/clinical-intelligence/domain/interfaces/DropoutRepository.ts">
export interface DropoutRepository {
    getPatientSessionData(patientId?: string): Promise<any[]>;
}
</file>

<file path="src/clinical-intelligence/domain/models/DropoutRisk.ts">
export interface DropoutRisk {
    patientId: string;
    name: string;
    riskScore: number;
    status: 'CRITICAL' | 'MODERATE' | 'LOW';
    bufferDays: number;
    factors: string[];
}
</file>

<file path="src/clinical-intelligence/domain/ClinicalError.ts">
export const CLINICAL_RESPONSES = {
    SUCCESS: {
        ANALYSIS_COMPLETED: {
            code: 200,
            status: 'success',
            message: 'Análisis clínico completado correctamente.'
        }
    },
    ERRORS: {
        NO_DATA: {
            code: 'NO_HEALTH_DATA_FOUND',
            message: 'No hay datos suficientes para realizar el análisis.',
            status: 404
        },
        ANALYSIS_FAILED: {
            code: 'HEALTH_ANALYSIS_FAILED',
            message: 'Error interno al procesar los datos clínicos.',
            status: 500
        }
    }
} as const;
</file>

<file path="src/clinical-intelligence/infrastructure/__tests__/predictDropout.test.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { CLINICAL_RESPONSES } from '../../domain/ClinicalError';

describe('E2E: Predict Dropout Flow', () => {
    let app: any;

    beforeAll(async () => {
        app = build();
        await app.ready();
    });

    afterAll(async () => {
        await app.close();
    });

    it('should return a full list of dropout risks for all patients', async () => {
        await initTestDatabase();

        const response = await app.inject({
            method: 'GET',
            url: '/clinical-intelligence/predict-dropout'
        });

        expect(response.statusCode).toBe(200);
        const body = response.json();
        expect(body.status).toBe('success');
        expect(Array.isArray(body.data)).toBe(true);
    });

    it('should return 404 if the patient does not exist or has no data', async () => {
        const response = await app.inject({
            method: 'GET',
            url: '/clinical-intelligence/predict-dropout/999999'
        });

        expect(response.statusCode).toBe(CLINICAL_RESPONSES.ERRORS.NO_DATA.status);
        expect(response.json().error.code).toBe(CLINICAL_RESPONSES.ERRORS.NO_DATA.code);
    });
});
</file>

<file path="src/clinical-intelligence/infrastructure/database/__tests__/SupabaseDropoutRepository.test.ts">
import { supabaseClient } from '@common/infrastructure/database/supabaseClient';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { SupabaseDropoutRepository } from '../SupabaseDropoutRepository';

describe('SupabaseDropoutRepository', () => {
    const repository = new SupabaseDropoutRepository(supabaseClient as any);

    beforeAll(async () => {
        await initTestDatabase();
    });

    it('should fetch raw session data from the database correctly', async () => {
        const data = await repository.getPatientSessionData();

        expect(data.length).toBeGreaterThan(0);
        expect(data[0]).toHaveProperty('patientId');
        expect(data[0]).toHaveProperty('sessionStatus');
    });

    it('should filter data by patientId when provided', async () => {
        const allData = await repository.getPatientSessionData();
        const targetId = allData[0].patientId;

        const filteredData = await repository.getPatientSessionData(targetId);

        const allMatch = filteredData.every(row => row.patientId === targetId);
        expect(allMatch).toBe(true);
    });
});
</file>

<file path="src/clinical-intelligence/infrastructure/database/SupabaseDropoutRepository.ts">
import { DropoutRepository } from '../../domain/interfaces/DropoutRepository';
import { DBClientService } from '@common/infrastructure/database/supabaseClient';

export class SupabaseDropoutRepository implements DropoutRepository {
    constructor(private readonly supabase: DBClientService) {}

    async getPatientSessionData(patientId?: string): Promise<any[]> {
        let query = this.supabase
            .from('Patient')
            .select(`
                patientId: id,
                name,
                PatientSession (
                    sessionId: id,
                    sessionStatus: state,
                    assignedDate: assigned_date,
                    sessionUpdate: created_at,
                    postEval: post_evaluation
                )
            `);

        if (patientId) {
            query = query.eq('id', parseInt(patientId));
        }

        const { data, error } = await query;

        if (error) throw error;

        return (data as any[]).flatMap(patient =>
            patient.PatientSession.map((session: any) => ({
                patientId: patient.patientId,
                name: patient.name,
                ...session
            }))
        );
    }
}
</file>

<file path="src/clinical-intelligence/infrastructure/endpoints/__tests__/predictDropout.test.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { CLINICAL_RESPONSES } from '../../../domain/ClinicalError';

describe('Endpoint: GET /clinical-intelligence/predict-dropout', () => {
    let app: any;

    beforeAll(async () => {
        app = build();
        await app.ready();
    });

    afterAll(async () => {
        await app.close();
    });

    it('should return 200 and the list of patients when no ID is provided', async () => {
        await initTestDatabase();

        const response = await app.inject({
            method: 'GET',
            url: '/clinical-intelligence/predict-dropout'
        });

        const successConfig = CLINICAL_RESPONSES.SUCCESS.ANALYSIS_COMPLETED;

        expect(response.statusCode).toBe(successConfig.code);
        expect(response.json()).toEqual(expect.objectContaining({
            status: successConfig.status,
            message: successConfig.message,
            data: expect.any(Array)
        }));
    });

    it('should return 200 and a single object when a valid patientId is provided', async () => {
        const { patientId } = await initTestDatabase();

        const response = await app.inject({
            method: 'GET',
            url: `/clinical-intelligence/predict-dropout/${patientId}`
        });

        expect(response.statusCode).toBe(200);
        expect(response.json().data).toHaveProperty('patientId', patientId);
        expect(Array.isArray(response.json().data)).toBe(false);
    });

    it('should return 404 when the patientId does not exist in the system', async () => {
        const errorConfig = CLINICAL_RESPONSES.ERRORS.NO_DATA;

        const response = await app.inject({
            method: 'GET',
            url: '/clinical-intelligence/predict-dropout/non-existent-id'
        });

        expect(response.statusCode).toBe(errorConfig.status);
        expect(response.json().error).toEqual({
            code: errorConfig.code,
            message: errorConfig.message
        });
    });
});
</file>

<file path="src/common/domain/model/UserParameters.ts">
export type UserId = string;
export type PatientId = number;
export type Email = string;
export type Username = string;
</file>

<file path="src/identity/infrastructure/http/authenticate.ts">
import { FastifyReply, FastifyRequest } from 'fastify';

export const authenticate = async (
    request: FastifyRequest,
    reply: FastifyReply
) => {
    try {
        await request.jwtVerify();
        const decoded = request.user as any;
        request.user = {
            id: decoded.sub
        };
    } catch (err) {
        reply.status(401).send({
            error: 'Invalid or expired token'
        });
    }
};
</file>

<file path="src/messaging/application/ManageNotifications.ts">
import { NotificationRepository, Notification } from "../domain/interfaces/NotificationRepository";

export class ManageNotifications {
    constructor(private readonly repo: NotificationRepository) {}

    async getUnreadCount(patientId: number): Promise<number> {
        return await this.repo.getPendingCount(patientId);
    }

    async getInbox(patientId: number): Promise<Notification[]> {
        return await this.repo.getPatientNotifications(patientId);
    }

    async readMessage(patientId: number, messageId: string): Promise<Notification | null> {
        const message = await this.repo.getNotificationDetail(patientId, messageId);
        if (message && message.is_read === false) {
            await this.repo.markAsRead(patientId, messageId);
        }
        return message;
    }

    async deleteMessage(patientId: number, messageId: string): Promise<void> {
        await this.repo.deleteNotification(patientId, messageId);
    }
}
</file>

<file path="src/messaging/domain/interfaces/NotificationRepository.ts">
export interface Notification {
    id: string;
    patient_id: number;
    subject: string;
    content: string;
    is_read: boolean;
    created_at: string;
}

export interface NotificationRepository {
    saveNotification(patientId: number, subject: string, content: string): Promise<void>;
    getPendingCount(patientId: number): Promise<number>;
    getPatientNotifications(patientId: number): Promise<Notification[]>;
    getNotificationDetail(patientId: number, notificationId: string): Promise<Notification | null>;
    markAsRead(patientId: number, notificationId: string): Promise<void>;
    deleteNotification(patientId: number, notificationId: string): Promise<void>;
}
</file>

<file path="src/messaging/domain/interfaces/PatientContactRepository.ts">
export interface PatientContactRepository {
    getEmailByPatientId(patientId: number): Promise<string | null>;
}
</file>

<file path="src/messaging/domain/MessagingError.ts">
export const MESSAGING_RESPONSES = {
    SUCCESS: {
        SEND_TO_PATIENT: {
            status: 'success',
            code: 200,
            message: 'Mensaje enviado correctamente al paciente.'
        },
        SEND_WEEKLY_STATS: {
            status: 'success',
            code: 200,
            getMessage: (count: number) => `Informes enviados a ${count} pacientes.`
        }
    },
    ERRORS: {
        PATIENT_EMAIL_NOT_FOUND: {
            code: 'PATIENT_EMAIL_NOT_FOUND',
            message: 'No se ha encontrado un email asociado a este paciente.',
            status: 404
        },
        NO_STATS_DATA: {
            code: 'NO_STATS_DATA',
            message: 'No hay actividad registrada para generar el informe semanal.',
            status: 404
        },
        MAIL_FAILURE: {
            code: 'MAIL_SENDING_FAILED',
            message: 'El servicio de mensajería no ha podido enviar el correo.',
            status: 500
        },
        INTERNAL_ERROR: {
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Ha ocurrido un error inesperado en el servidor.',
            status: 500
        }
    }
} as const;

export type MessagingErrorType = keyof typeof MESSAGING_RESPONSES.ERRORS;
</file>

<file path="supabase/.temp/cli-latest">
v2.72.7
</file>

<file path="supabase/migrations/20260115171404_secure_unrestricted_tables.sql">
-- 1. Habilitar RLS en las tablas UNRESTRICTED
ALTER TABLE public."SecurityLogs" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."biometric_minutes" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."context_intervals" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."patientnotifications" ENABLE ROW LEVEL SECURITY;

-- 2. SECURITYLOGS: Solo permitir inserción
DROP POLICY IF EXISTS "Allow authenticated insert only" ON public."SecurityLogs";
CREATE POLICY "Allow authenticated insert only"
ON public."SecurityLogs"
FOR INSERT
TO authenticated
WITH CHECK (true);

-- 3. BIOMETRIC_MINUTES: Acceso total para usuarios autenticados
DROP POLICY IF EXISTS "Allow authenticated select and insert" ON public."biometric_minutes";
CREATE POLICY "Allow authenticated select and insert"
ON public."biometric_minutes"
FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);

-- 4. CONTEXT_INTERVALS: Acceso total para usuarios autenticados
DROP POLICY IF EXISTS "Allow authenticated select and insert" ON public."context_intervals";
CREATE POLICY "Allow authenticated select and insert"
ON public."context_intervals"
FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);

-- 5. PATIENTNOTIFICATIONS: Acceso total (incluye DELETE)
DROP POLICY IF EXISTS "Allow authenticated full access" ON public."patientnotifications";
CREATE POLICY "Allow authenticated full access"
ON public."patientnotifications"
FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);
</file>

<file path=".env.test.example">
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_JWT_SECRET=your-jwt-secret
NODE_ENV=test
</file>

<file path=".prettierrc">
{
  "semi": true,
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "trailingComma": "all",
  "arrowParens": "always",
  "endOfLine": "lf"
}
</file>

<file path="eslint.config.cjs">
const tseslint = require('@typescript-eslint/eslint-plugin');
const tsParser = require('@typescript-eslint/parser');

module.exports = [
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'unused-imports': require('eslint-plugin-unused-imports'),
    },
    rules: {
      'no-console': 'warn',
      'no-debugger': 'error',
      eqeqeq: ['error', 'always'],
      curly: ['error', 'all'],
      quotes: ['error', 'single'],

      'no-unused-vars': 'off',

      '@typescript-eslint/no-unused-vars': ['warn', { argsIgnorePattern: '^_' }],

      'unused-imports/no-unused-imports': 'warn',
      'unused-imports/no-unused-vars': [
        'warn',
        { vars: 'all', varsIgnorePattern: '^_', args: 'after-used', argsIgnorePattern: '^_' },
      ],

      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/no-explicit-any': 'warn',
    },
  },
];
</file>

<file path="tsconfig.jest.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "baseUrl": "./src",
    "types": ["node", "jest"],
    "paths": {
      "@common/*": ["common/*"],
      "@auth/*": ["auth/*"],
      "@user/*": ["user/*"],
      "@src/*": ["./*"]
    }
  },
  "include": ["src/**/*", "src/**/__tests__/**/*", "src/**/*.test.ts", "src/**/*.spec.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/biometrics/application/use-cases/SyncDailyBiometrics.ts">
import { S3Client, ListObjectsV2Command, GetObjectCommand } from "@aws-sdk/client-s3";
import { supabaseClient } from '@common/infrastructure/database/supabaseClient';
import { parse } from 'csv-parse/sync';

export class SyncDailyBiometrics {
    private s3 = new S3Client({
        region: "us-east-1",
        credentials: {
            accessKeyId: process.env.EMPATICA_AWS_ACCESS_KEY!,
            secretAccessKey: process.env.EMPATICA_AWS_SECRET_KEY!
        }
    });
    private BUCKET = "empatica-us-east-1-prod-data";
    private PREFIX = "v2/451/";

    async execute(date: string): Promise<any> {
        const listCommand = new ListObjectsV2Command({
            Bucket: this.BUCKET,
            Prefix: this.PREFIX
        });

        const { Contents } = await this.s3.send(listCommand);
        if (!Contents) return { filesProcessed: 0, message: "No se encontraron archivos en el bucket" };

        // Filtramos archivos por fecha, igual que id_serial + '_' + date en tu script
        const dailyFiles = Contents.filter(obj => obj.Key && obj.Key.includes(`_${date}_`));
        let totalInserted = 0;

        for (const file of dailyFiles) {
            try {
                const response = await this.s3.send(new GetObjectCommand({ Bucket: this.BUCKET, Key: file.Key! }));
                const csv = await response.Body?.transformToString();
                if (!csv) continue;

                const fileName = file.Key!.split('/').pop() || "";
                const parts = fileName.split('_');
                const participantId = parts[0];
                const metricType = parts[parts.length - 1].replace('.csv', '');

                const records = parse(csv, { columns: true, skip_empty_lines: true });

                // Mapeo dinámico basado en tu script visualiza.py
                const rows = records
                    .filter((r: any) => r.missing_value_reason !== 'device_not_recording')
                    .map((r: any) => {
                        const ts = r.timestamp_iso || r.timestamp;
                        return {
                            participant_full_id: participantId,
                            timestamp_iso: ts,
                            timestamp_unix_ms: new Date(ts).getTime(),
                            pulse_rate_bpm: metricType === 'pulse-rate' ? parseFloat(r.pulse_rate_bpm || r.value || r.rate || 0) : null,
                            eda_scl_usiemens: metricType === 'eda' ? parseFloat(r.eda_scl_usiemens || r.value || r.eda || 0) : null,
                            temperature_celsius: metricType === 'temperature' ? parseFloat(r.temperature_celsius || r.value || r.temp || 0) : null,
                            prv_rmssd_ms: metricType === 'prv' ? parseFloat(r.value || 0) : null,
                            respiratory_rate_brpm: metricType === 'respiratory-rate' ? parseFloat(r.value || 0) : null
                        };
                    });

                if (rows.length > 0) {
                    const { error } = await (supabaseClient as any).from('biometric_minutes').insert(rows);
                    if (error) throw error;
                    totalInserted += rows.length;
                }
            } catch (e) {
                continue; // Replica el 'continue' de tu script ante errores de descarga
            }
        }
        return { filesFound: dailyFiles.length, rowsInserted: totalInserted };
    }
}
</file>

<file path="src/biometrics/infrastructure/endpoints/__tests__/getSessionReport.test.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';

describe('Endpoint: GET /biometrics/session-report/:patientId/:sessionId', () => {
    let app: any;
    let patientId: number;
    let sessionId: string;

    beforeAll(async () => {
        app = build();
        await app.ready();
        const seed = await initTestDatabase();
        patientId = seed.patientId;

        const { supabaseClient } = require('@common/infrastructure/database/supabaseClient');
        const { data } = await supabaseClient
            .from('PatientSession')
            .select('id')
            .eq('patient_id', patientId)
            .limit(1)
            .single();

        sessionId = data.id.toString();
    });

    afterAll(async () => {
        await app.close();
    });

    it('should return 200 and the unified report', async () => {
        const response = await app.inject({
            method: 'GET',
            url: `/biometrics/session-report/${patientId}/${sessionId}`
        });

        expect(response.statusCode).toBe(200);
        expect(response.json().status).toBe('success');
    });

    it('should return error status for non-existent session', async () => {
        const response = await app.inject({
            method: 'GET',
            url: `/biometrics/session-report/${patientId}/999999`
        });

        expect(response.statusCode).toBe(500);
    });
});
</file>

<file path="src/biometrics/infrastructure/endpoints/presenceMinute.ts">
import { FastifyInstance } from 'fastify';
import { RegisterPresenceMinute } from '../../application/use-cases/RegisterPresenceMinute';

export default function presenceMinute() {
    const useCase = new RegisterPresenceMinute();

    return async function (fastify: FastifyInstance) {
        fastify.post('/presence/minute', async (request, reply) => {
            try {
                const patientId = (request as any).user?.id ?? "f1570f10-415e-480a-9ff1-a9dc777d5cdb";

                const { minuteTsUtc, contextType, sessionId } = request.body as any;

                const { data, action } = await useCase.execute({
                    patientId,
                    minuteTsUtc,
                    contextType,
                    sessionId: sessionId ?? null
                });

                return reply.status(200).send({
                    status: 'ok',
                    action,
                    intervalId: (data as any).id
                });
            } catch (e: any) {
                const msg = e.message;
                const code = msg === 'Unauthorized' ? 401 : (msg.includes('must be') || msg.includes('Invalid') ? 400 : 500);
                return reply.status(code).send({ status: 'error', message: msg });
            }
        });
    };
}
</file>

<file path="src/clinical-intelligence/application/DropoutAnalysisService.ts">
import { DropoutRepository } from '../domain/interfaces/DropoutRepository';
import { DropoutRisk } from '../domain/models/DropoutRisk';
import { CLINICAL_RESPONSES } from '../domain/ClinicalError';

export class DropoutAnalysisService {
    constructor(private readonly repository: DropoutRepository) {}

    async execute(patientId?: string): Promise<DropoutRisk[] | { type: string }> {
        try {
            const data = await this.repository.getPatientSessionData(patientId);

            if (!data || data.length === 0) {
                return { type: CLINICAL_RESPONSES.ERRORS.NO_DATA.code };
            }

            const patientsMap = new Map<string, { name: string, sessions: any[] }>();

            data.forEach(row => {
                if (!patientsMap.has(row.patientId)) {
                    patientsMap.set(row.patientId, { name: row.name, sessions: [] });
                }
                if (row.sessionId) {
                    patientsMap.get(row.patientId)!.sessions.push(row);
                }
            });

            const results: DropoutRisk[] = Array.from(patientsMap.entries()).map(([id, p]) => {
                const now = new Date();
                const sessions = p.sessions.sort((a, b) =>
                    new Date(a.assignedDate).getTime() - new Date(b.assignedDate).getTime()
                );

                const nextSession = sessions.find(s => s.sessionStatus !== 'completed');
                const lastCompleted = [...sessions].reverse().find(s => s.sessionStatus === 'completed');

                let riskScore = 0;
                let factors: string[] = [];

                if (nextSession) {
                    const assignedDate = new Date(nextSession.assignedDate);
                    const diffDays = Math.ceil((assignedDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

                    if (diffDays < 0) {
                        riskScore += 50;
                        factors.push('Retraso en calendario');
                    } else if (diffDays > 7) {
                        riskScore -= 30;
                    }

                    if (nextSession.sessionStatus === 'in_progress' && nextSession.sessionUpdate) {
                        const lastUpdate = new Date(nextSession.sessionUpdate);
                        const hoursSinceUpdate = (now.getTime() - lastUpdate.getTime()) / (1000 * 60 * 60);

                        if (hoursSinceUpdate > 24) {
                            riskScore += 35;
                            factors.push('In-progress antiguo (>24h)');
                        } else if (hoursSinceUpdate > 1) {
                            riskScore += 10;
                            factors.push('In-progress reciente');
                        }
                    }
                }

                if (lastCompleted && lastCompleted.postEval > 7) {
                    riskScore += 20;
                    factors.push('Mareo elevado en ultima sesion');
                }

                return {
                    patientId: id,
                    name: p.name,
                    riskScore: Math.max(0, Math.min(100, riskScore)),
                    status: riskScore > 70 ? 'CRITICAL' : riskScore > 40 ? 'MODERATE' : 'LOW',
                    bufferDays: nextSession ? Math.ceil((new Date(nextSession.assignedDate).getTime() - now.getTime()) / (1000 * 60 * 60 * 24)) : 0,
                    factors
                };
            });

            return results.sort((a, b) => b.riskScore - a.riskScore);

        } catch (error) {
            return { type: CLINICAL_RESPONSES.ERRORS.ANALYSIS_FAILED.code };
        }
    }
}
</file>

<file path="src/clinical-intelligence/infrastructure/endpoints/predictDropout.ts">
import { FastifyInstance } from 'fastify';
import { DropoutAnalysisService } from '../../application/DropoutAnalysisService';
import { DropoutRepository } from '../../domain/interfaces/DropoutRepository';
import { CLINICAL_RESPONSES } from '../../domain/ClinicalError';

export default function predictDropout(dependencies: { dropoutRepo: DropoutRepository }) {
    return async function (fastify: FastifyInstance) {
        const service = new DropoutAnalysisService(dependencies.dropoutRepo);

        fastify.get('/clinical-intelligence/predict-dropout/:patientId?', async (request, reply) => {
            const { patientId } = request.params as { patientId?: string };

            if (patientId && isNaN(Number(patientId))) {
                const noData = CLINICAL_RESPONSES.ERRORS.NO_DATA;
                return reply.status(noData.status).send({
                    status: 'error',
                    error: { code: noData.code, message: noData.message }
                });
            }

            try {
                const result = await service.execute(patientId);

                if ('type' in result) {
                    const errorConfig = Object.values(CLINICAL_RESPONSES.ERRORS).find(
                        (e) => e.code === result.type
                    );

                    if (!errorConfig) {
                        const internal = CLINICAL_RESPONSES.ERRORS.ANALYSIS_FAILED;
                        return reply.status(internal.status).send({
                            status: 'error',
                            error: { code: internal.code, message: internal.message }
                        });
                    }

                    return reply.status(errorConfig.status).send({
                        status: 'error',
                        error: { code: errorConfig.code, message: errorConfig.message }
                    });
                }

                const successConfig = CLINICAL_RESPONSES.SUCCESS.ANALYSIS_COMPLETED;

                if (patientId && (result as any[]).length === 0) {
                    const noData = CLINICAL_RESPONSES.ERRORS.NO_DATA;
                    return reply.status(noData.status).send({
                        status: 'error',
                        error: { code: noData.code, message: noData.message }
                    });
                }

                return reply.status(successConfig.code).send({
                    status: successConfig.status,
                    message: successConfig.message,
                    data: patientId ? result[0] : result
                });

            } catch (error) {
                fastify.log.error(error);
                const internal = CLINICAL_RESPONSES.ERRORS.ANALYSIS_FAILED;
                return reply.status(internal.status).send({
                    status: 'error',
                    error: { code: internal.code, message: internal.message }
                });
            }
        });
    };
}
</file>

<file path="src/common/infrastructure/server/securityLogger.ts">
import { FastifyRequest, FastifyReply } from 'fastify';
import { supabaseClient } from '../database/supabaseClient';

export const securityLogger = async (
    request: FastifyRequest,
    _reply: FastifyReply
): Promise<void> => {
    if (request.url === '/ping' || request.routeOptions.url === '/ping') {
        return;
    }

    const user = request.user as any;
    const logEntry = {
        user_id: user?.id || 'ANONYMOUS',
        endpoint: `${request.method} ${request.url}`,
        ip_address: request.ip,
        user_agent: request.headers['user-agent'] || 'UNKNOWN',
        created_at: new Date().toISOString()
    };

    supabaseClient
        .from('SecurityLogs')
        .insert([logEntry])
        .then(({ error }) => {
            if (error) console.error('Security Log Error:', error.message);
        });
};
</file>

<file path="src/identity/infrastructure/database/repositories/SupabaseUserRepository.ts">
import { UserRepository } from '../../../domain/interfaces/repositories/UserRepository';
import { UserId } from "@common/domain/model/UserParameters";
import { supabaseClient } from '@common/infrastructure/database/supabaseClient';

type DBClient = typeof supabaseClient;

export class SupabaseUserRepository implements UserRepository {
    constructor(
        private readonly client: DBClient
    ) {}

    async isProfessional(userId: UserId): Promise<boolean> {
        const { data, error } = await this.client
            .from('Patient')
            .select('id')
            .eq('user_id', userId)
            .single();

        if (error && error.code === 'PGRST116') {
            return true;
        }

        if (data) {
            return false;
        }

        if (error) {
            throw error;
        }

        return true;
    }

    async isPatient(userId: UserId): Promise<boolean> {
        const { data, error } = await this.client
            .from('Patient')
            .select('id')
            .eq('user_id', userId)
            .single();

        if (error && error.code !== 'PGRST116') {
            throw error;
        }

        return !!data;
    }
}
</file>

<file path="src/messaging/infrastructure/__tests__/e2e/messagingFlow.e2e.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { MESSAGING_RESPONSES } from '../../../domain/MessagingError';

describe('Messaging System E2E Flow', () => {
    let app: any;

    beforeAll(async () => {
        app = build();
        await app.ready();
        await initTestDatabase();
    });

    afterAll(async () => {
        await app.close();
    });

    it('should complete the weekly reporting cycle for all active patients', async () => {
        const response = await app.inject({
            method: 'POST',
            url: '/messaging/send-weekly-stats'
        });

        const successConfig = MESSAGING_RESPONSES.SUCCESS.SEND_WEEKLY_STATS;

        expect(response.statusCode).toBe(200);
        expect(response.json()).toEqual({
            status: 'success',
            message: successConfig.getMessage(1)
        });
    });

    it('should complete a manual message send flow to a specific patient', async () => {
        const response = await app.inject({
            method: 'POST',
            url: '/messaging/send-to-patient',
            payload: {
                patientId: 1,
                subject: 'Mensaje E2E',
                body: 'Validando el flujo completo de mensajería.'
            }
        });

        const successConfig = MESSAGING_RESPONSES.SUCCESS.SEND_TO_PATIENT;

        expect(response.statusCode).toBe(200);
        expect(response.json()).toEqual({
            status: 'success',
            message: successConfig.message
        });
    });

    it('should return 404 when sending to a non-existent patient', async () => {
        const response = await app.inject({
            method: 'POST',
            url: '/messaging/send-to-patient',
            payload: {
                patientId: 9999,
                subject: 'Error Test',
                body: 'Fail'
            }
        });

        const errorConfig = MESSAGING_RESPONSES.ERRORS.PATIENT_EMAIL_NOT_FOUND;

        expect(response.statusCode).toBe(404);
        expect(response.json().error.code).toBe(errorConfig.code);
    });
});
</file>

<file path="src/messaging/infrastructure/database/__tests__/SupabasePatientContactRepository.test.ts">
import { SupabasePatientContactRepository } from '../SupabasePatientContactRepository';
import { supabaseClient } from '@common/infrastructure/database/supabaseClient';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';
import { randomUUID } from 'node:crypto';

describe('SupabasePatientContactRepository', () => {
    const repository = new SupabasePatientContactRepository(supabaseClient);
    let seededPatientId: number;

    beforeAll(async () => {
        const seed = await initTestDatabase();
        seededPatientId = seed.patientId;
    });

    it('should return the correct email for the dynamic seeded patient', async () => {
        const email = await repository.getEmailByPatientId(seededPatientId);
        expect(email).toBe('benat@test.com');
    });

    it('should return null when the patient id does not exist', async () => {
        const email = await repository.getEmailByPatientId(999999);
        expect(email).toBeNull();
    });

    it('should return null when the patient email is an empty string', async () => {
        const uniqueUser = randomUUID();

        const { data, error } = await supabaseClient.from('Patient').insert({
            user_id: uniqueUser,
            name: 'Sin Email',
            surname: 'Test',
            email: '',
            phone: '000',
            birth_date: '1990-01-01',
            gender: 'M',
            username: `tmp_${uniqueUser.substring(0, 5)}`
        }).select().single();

        if (error || !data) {
            throw new Error(`Fallo al insertar paciente sin email: ${error?.message}`);
        }

        const email = await repository.getEmailByPatientId(data.id);
        expect(email).toBeNull();
    });
});
</file>

<file path="src/messaging/infrastructure/database/SupabaseNotificationRepository.ts">
import { NotificationRepository, Notification } from '../../domain/interfaces/NotificationRepository';
import { DBClientService } from '@common/infrastructure/database/supabaseClient';

export class SupabaseNotificationRepository implements NotificationRepository {
    constructor(private readonly supabase: DBClientService) {}

    async saveNotification(patientId: number, subject: string, content: string): Promise<void> {
        await this.supabase
            .from('PatientNotifications')
            .insert({
                patient_id: patientId,
                subject: subject,
                content: content,
                is_read: false
            });
    }

    async getPendingCount(patientId: number): Promise<number> {
        const { count } = await this.supabase
            .from('PatientNotifications')
            .select('*', { count: 'exact', head: true })
            .eq('patient_id', patientId)
            .eq('is_read', false);
        return count || 0;
    }

    async getPatientNotifications(patientId: number): Promise<Notification[]> {
        const { data } = await this.supabase
            .from('PatientNotifications')
            .select('id, subject, is_read, created_at')
            .eq('patient_id', patientId)
            .order('created_at', { ascending: false });

        return (data as Notification[]) || [];
    }

    async getNotificationDetail(patientId: number, notificationId: string): Promise<Notification | null> {
        const { data } = await this.supabase
            .from('PatientNotifications')
            .select('subject, content, created_at')
            .eq('id', notificationId)
            .eq('patient_id', patientId)
            .maybeSingle();

        return (data as Notification) || null;
    }

    async markAsRead(patientId: number, notificationId: string): Promise<void> {
        await this.supabase
            .from('PatientNotifications')
            .update({ is_read: true })
            .eq('id', notificationId)
            .eq('patient_id', patientId);
    }

    async deleteNotification(patientId: number, notificationId: string): Promise<void> {
        await this.supabase
            .from('PatientNotifications')
            .delete()
            .eq('id', notificationId)
            .eq('patient_id', patientId);
    }
}
</file>

<file path="src/messaging/infrastructure/database/SupabasePatientContactRepository.ts">
import { PatientContactRepository } from "../../domain/interfaces/PatientContactRepository";
import { DBClientService } from "@src/common/infrastructure/database/supabaseClient";

export class SupabasePatientContactRepository implements PatientContactRepository {
    constructor(private readonly supabase: DBClientService) {}

    async getEmailByPatientId(patientId: number): Promise<string | null> {
        // Aseguramos que patientId sea tratado como número para la consulta int8
        const targetId = Number(patientId);

        const { data, error } = await this.supabase
            .from('Patient')
            .select('email')
            .eq('id', targetId)
            .maybeSingle();

        if (error) {
            console.error(`❌ Error en Supabase (ID ${targetId}):`, error.message);
            return null;
        }

        if (!data || !data.email) {
            console.warn(`⚠️ No se encontró email para el paciente ID: ${targetId}`);
            return null;
        }

        return data.email;
    }
}
</file>

<file path="src/messaging/infrastructure/endpoints/patientNotifications.ts">
import { FastifyInstance } from 'fastify';
import { ManageNotifications } from '../../application/ManageNotifications';

export default function patientNotifications(deps: any) {
    return async function (fastify: FastifyInstance) {
        const service = new ManageNotifications(deps.notificationRepo);

        fastify.get('/messaging/notifications/unread-count', async (request) => {
            const patientId = (request as any).user?.patientId ?? 1;
            const count = await service.getUnreadCount(patientId);
            return { status: 'success', count };
        });

        fastify.get('/messaging/notifications', async (request) => {
            const patientId = (request as any).user?.patientId ?? 1;
            const messages = await service.getInbox(patientId);
            return { status: 'success', data: messages };
        });

        fastify.get('/messaging/notifications/:id', async (request, reply) => {
            const patientId = (request as any).user?.patientId ?? 1;
            const messageId = (request.params as any).id;
            const message = await service.readMessage(patientId, messageId);

            if (!message) {
                return reply.status(404).send({ status: 'error', message: 'Not found' });
            }
            return { status: 'success', data: message };
        });

        fastify.delete('/messaging/notifications/:id', async (request) => {
            const patientId = (request as any).user?.patientId ?? 1;
            const messageId = (request.params as any).id;
            await service.deleteMessage(patientId, messageId);
            return { status: 'success' };
        });
    };
}
</file>

<file path="src/types/fastify.d.ts">
import { UserId } from '@common/domain/model/UserParameters';
import * as fastify from 'fastify';

declare module 'fastify' {
    export interface FastifyRequest {
        user?: {
            id: UserId;
        };
    }
}
</file>

<file path=".gitignore">
node_modules
dist/
data/*.sqlite
*.log
.DS_Store
data
.env
.env.test
.env.production
.env.local
</file>

<file path="jest.config.js">
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    roots: ['<rootDir>/src'],
    moduleFileExtensions: ['ts', 'js', 'json', 'node'],
    testMatch: ['**/__tests__/**/*.(test|spec).ts', '**/?(*.)+(test|spec).ts'],
    clearMocks: true,
    forceExit: true,
    detectOpenHandles: true,
    testTimeout: 30000,
    transform: {
        '^.+\\.ts$': [
            'ts-jest',
            {
                tsconfig: './tsconfig.jest.json',
            },
        ],
    },
    moduleNameMapper: {
        '^@common/(.*)$': '<rootDir>/src/common/$1',
        '^@auth/(.*)$': '<rootDir>/src/auth/$1',
        '^@user/(.*)$': '<rootDir>/src/user/$1',
        '^@src/(.*)$': '<rootDir>/src/$1',
    },
    modulePaths: ['<rootDir>/src'],
    collectCoverageFrom: [
        'src/**/*.ts',
        '!src/**/*.d.ts',
        '!src/**/index.ts',
        '!src/**/__tests__/**',
        '!src/**/*.spec.ts',
    ],
    coverageDirectory: 'coverage',
};
</file>

<file path="src/common/infrastructure/database/initTestDatabase.ts">
import { supabaseClient } from './supabaseClient';
import { randomUUID } from 'node:crypto';

export async function initTestDatabase() {
    await supabaseClient.from('Survey').delete().neq('id', 0);
    await supabaseClient.from('PatientSession').delete().neq('id', 0);
    await supabaseClient.from('Session').delete().neq('id', 0);
    await supabaseClient.from('Patient').delete().neq('id', 0);
    await supabaseClient.from('Question').delete().neq('id', 0);
    await supabaseClient.from('ContextIntervals').delete().neq('id', 0);
    await supabaseClient.from('BiometricMinutes').delete().neq('id', 0);

    const uniqueUserId = randomUUID();

    const { data: patientData, error: pError } = await supabaseClient
        .from('Patient')
        .upsert({
            user_id: uniqueUserId,
            name: 'Beñat',
            surname: 'Test',
            email: 'benat@test.com',
            phone: '600000000',
            birth_date: '1990-01-01',
            gender: 'M',
            username: `user_${uniqueUserId.split('-')[0]}`
        }, { onConflict: 'user_id' })
        .select();

    if (pError || !patientData || patientData.length === 0) {
        throw new Error(`Error seeding Patient: ${pError?.message}`);
    }

    const { data: sessionData, error: sError } = await supabaseClient
        .from('Session')
        .upsert({
            number: 1,
            day_offset: 1
        })
        .select();

    if (sError || !sessionData || sessionData.length === 0) {
        throw new Error(`Error seeding Session: ${sError?.message}`);
    }

    await supabaseClient.from('Question').upsert({ id: 1 }, { onConflict: 'id' });

    const lastWeekDate = new Date();
    lastWeekDate.setDate(lastWeekDate.getDate() - 3);

    const { data: psData, error: psError } = await supabaseClient
        .from('PatientSession')
        .insert({
            session_id: sessionData[0].id,
            patient_id: patientData[0].id,
            state: 'completed',
            assigned_date: lastWeekDate.toISOString().split('T')[0],
            pre_evaluation: 2,
            post_evaluation: 5
        })
        .select('id')
        .single();

    if (psError || !psData) {
        throw new Error(`Error seeding PatientSession: ${psError?.message}`);
    }

    const now = new Date();
    now.setUTCSeconds(0, 0);

    const preStart = new Date(now.getTime() - 30 * 60_000);
    const preEnd = new Date(now.getTime() - 20 * 60_000);
    const sesStart = new Date(now.getTime() - 20 * 60_000);
    const sesEnd = new Date(now.getTime() - 10 * 60_000);
    const postStart = new Date(now.getTime() - 10 * 60_000);
    const postEnd = new Date(now.getTime());

    await supabaseClient.from('ContextIntervals').insert([
        {
            patient_id: patientData[0].id.toString(),
            context_type: 'dashboard',
            session_id: null,
            start_minute_utc: preStart.toISOString(),
            end_minute_utc: preEnd.toISOString(),
            attempt_no: null
        },
        {
            patient_id: patientData[0].id.toString(),
            context_type: 'session',
            session_id: psData.id.toString(),
            start_minute_utc: sesStart.toISOString(),
            end_minute_utc: sesEnd.toISOString(),
            attempt_no: 1
        },
        {
            patient_id: patientData[0].id.toString(),
            context_type: 'dashboard',
            session_id: null,
            start_minute_utc: postStart.toISOString(),
            end_minute_utc: postEnd.toISOString(),
            attempt_no: null
        }
    ]);

    const participant_full_id = patientData[0].id.toString();

    await supabaseClient.from('BiometricMinutes').insert([
        {
            participant_full_id,
            timestamp_iso: preStart.toISOString(),
            timestamp_unix_ms: preStart.getTime(),
            eda_scl_usiemens: 1.2,
            prv_rmssd_ms: 30,
            pulse_rate_bpm: 70,
            temperature_celsius: 36.5,
            spo2_percentage: 98
        },
        {
            participant_full_id,
            timestamp_iso: sesStart.toISOString(),
            timestamp_unix_ms: sesStart.getTime(),
            eda_scl_usiemens: 1.6,
            prv_rmssd_ms: 25,
            pulse_rate_bpm: 80,
            temperature_celsius: 36.7,
            spo2_percentage: 97
        },
        {
            participant_full_id,
            timestamp_iso: postStart.toISOString(),
            timestamp_unix_ms: postStart.getTime(),
            eda_scl_usiemens: 1.1,
            prv_rmssd_ms: 35,
            pulse_rate_bpm: 68,
            temperature_celsius: 36.4,
            spo2_percentage: 99
        }
    ]);

    return { patientId: patientData[0].id };
}
</file>

<file path="src/messaging/application/__tests__/SendToPatient.spec.ts">
import { SendToPatient } from '../SendToPatient';

describe('SendToPatient Service', () => {
    const mockPatientRepo = { getEmailByPatientId: jest.fn() };
    const mockMailRepo = { send: jest.fn() };
    const mockNotificationRepo = {
        saveNotification: jest.fn(),
        getPendingCount: jest.fn()
    };

    const service = new SendToPatient(
        mockPatientRepo as any,
        mockMailRepo as any,
        mockNotificationRepo as any
    );

    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('should return true when patient email exists and mail is sent', async () => {
        mockPatientRepo.getEmailByPatientId.mockResolvedValue('test@patient.com');
        mockNotificationRepo.getPendingCount.mockResolvedValue(1);
        mockMailRepo.send.mockResolvedValue({ success: true });

        const result = await service.execute({
            patientId: 1,
            subject: 'Test',
            body: 'Body'
        });

        expect(result).toBe(true);
        expect(mockNotificationRepo.saveNotification).toHaveBeenCalledWith(1, 'Test', 'Body');
        expect(mockMailRepo.send).toHaveBeenCalledWith('test@patient.com', 'Test', 'Body', 1);
    });

    it('should return false when patient email is not found', async () => {
        mockPatientRepo.getEmailByPatientId.mockResolvedValue(null);

        const result = await service.execute({
            patientId: 99,
            subject: 'Test',
            body: 'Body'
        });

        expect(result).toBe(false);
        expect(mockNotificationRepo.saveNotification).not.toHaveBeenCalled();
        expect(mockMailRepo.send).not.toHaveBeenCalled();
    });
});
</file>

<file path="src/messaging/domain/interfaces/StatsRepository.ts">
export interface PatientStats {
    id?: number;
    email: string;
    completed: number;
    inProgress: number;
    notStarted: number;
    sessions?: { state: string }[];
}

export interface StatsRepository {
    getAllPatientsStats(): Promise<PatientStats[]>;
}
</file>

<file path="src/messaging/infrastructure/database/SupabaseStatsRepository.ts">
import { StatsRepository, PatientStats } from "../../domain/interfaces/StatsRepository";
import { DBClientService } from "@src/common/infrastructure/database/supabaseClient";

export class SupabaseStatsRepository implements StatsRepository {
    constructor(private readonly supabase: DBClientService) {}

    async getAllPatientsStats(): Promise<PatientStats[]> {
        const { data, error } = await this.supabase
            .from('Patient')
            .select(`
                id,
                email,
                PatientSession (state)
            `);

        if (error) throw new Error("FETCH_PATIENTS_SESSIONS_ERROR");

        return (data || []).map(p => ({
            id: p.id,
            email: p.email,
            completed: 0,
            inProgress: 0,
            notStarted: 0,
            sessions: p.PatientSession
        }));
    }
}
</file>

<file path="src/messaging/infrastructure/endpoints/__tests__/sendToPatient.test.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';

jest.mock('@src/messaging/infrastructure/gmail/GmailApiMailRepository', () => ({
    GmailApiMailRepository: jest.fn().mockImplementation(() => ({
        send: jest.fn().mockResolvedValue({ success: true })
    }))
}));

describe('POST /messaging/send-to-patient', () => {
    let app: any;
    let patientId: number;

    beforeAll(async () => {
        app = build();
        await app.ready();
        const seed = await initTestDatabase();
        patientId = seed.patientId;
    });

    afterAll(async () => {
        await app.close();
    });

    it('should return 200 and success message when sending to a valid patient', async () => {
        const response = await app.inject({
            method: 'POST',
            url: '/messaging/send-to-patient',
            payload: {
                patientId,
                subject: 'Recordatorio de Salud',
                body: 'Este es un mensaje de prueba para el test de integración.'
            }
        });

        expect(response.statusCode).toBe(200);
        expect(response.json()).toEqual({
            status: 'success',
            message: 'Mensaje guardado y notificación enviada correctamente'
        });
    });

    it('should return 404 when the patient does not exist in the database', async () => {
        const response = await app.inject({
            method: 'POST',
            url: '/messaging/send-to-patient',
            payload: {
                patientId: 999999,
                subject: 'Inexistente',
                body: 'No debería enviarse'
            }
        });

        expect(response.statusCode).toBe(404);
        expect(response.json()).toEqual({
            status: 'error',
            message: 'No se encontró contacto'
        });
    });
});
</file>

<file path="src/messaging/infrastructure/worker/MessagingWorker.ts">
import { createClient } from '@supabase/supabase-js';
import nodemailer from 'nodemailer';
import nodeHtmlToImage from 'node-html-to-image';
import dotenv from 'dotenv';

dotenv.config();

const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!);

const transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: 2525,
    secure: false,
    auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
    },
    tls: {
        rejectUnauthorized: true
    }
});

async function runWorker() {
    while (true) {
        const { data: messages } = await supabase
            .from('MessagingOutbox')
            .select('*')
            .eq('status', 'PENDING')
            .limit(1);

        if (messages && messages.length > 0) {
            const msg = messages[0];
            try {
                await supabase.from('MessagingOutbox').update({ status: 'PROCESSING' }).eq('id', msg.id);

                if (msg.type === 'WEEKLY_STATS') {
                    const stats = msg.payload.stats;
                    const total = (stats.completed || 0) + (stats.notStarted || 0) + (stats.inProgress || 0);
                    const percentage = total > 0 ? (stats.completed / total) * 100 : 0;

                    const image = await nodeHtmlToImage({
                        html: '<html><body><div style="background: conic-gradient(#4caf50 {{p}}%, #eee 0); width:100px; height:100px; border-radius:50%;"></div></body></html>',
                        content: { p: percentage }
                    }) as Buffer;

                    await transporter.sendMail({
                        from: process.env.SMTP_FROM,
                        to: msg.payload.email,
                        subject: msg.payload.subject,
                        html: '<p>Tu balance semanal.</p>',
                        attachments: [{ filename: 'stats.png', content: image }]
                    });
                } else {
                    await transporter.sendMail({
                        from: process.env.SMTP_FROM,
                        to: msg.payload.email,
                        subject: msg.payload.subject,
                        text: msg.payload.body
                    });
                }

                await supabase.from('MessagingOutbox').delete().eq('id', msg.id);
            } catch (err: any) {
                await supabase.from('MessagingOutbox').update({ status: 'FAILED', last_error: err.message }).eq('id', msg.id);
            }
        }
        await new Promise(r => setTimeout(r, 10000));
    }
}

runWorker();
</file>

<file path="src/common/infrastructure/database/supabaseClient.ts">
import dotenv from 'dotenv';
import path from 'path';
import { createClient, SupabaseClient } from "@supabase/supabase-js";
import { Database } from "./supabaseTypes";

const envFile = process.env.NODE_ENV === 'test' ? '.env.test' : '.env';
dotenv.config({ path: path.resolve(process.cwd(), envFile) });

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error(`Faltan variables de entorno: SUPABASE_URL o SUPABASE_ANON_KEY`);
}

export type DBClientService = SupabaseClient<Database>;

export const supabaseClient: DBClientService = createClient<Database>(
    supabaseUrl,
    supabaseAnonKey
);
</file>

<file path="src/common/infrastructure/database/supabaseTypes.ts">
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.5"
  }
  public: {
    Tables: {
      BiometricMinutes: {
        Row: {
          attempt_no: number | null
          context_type: string | null
          created_at: string
          device_sn: string | null
          eda_scl_usiemens: number | null
          id: number
          import_batch_id: string | null
          participant_full_id: string
          patient_id: string | null
          prv_rmssd_ms: number | null
          pulse_rate_bpm: number | null
          respiratory_rate_brpm: number | null
          session_id: string | null
          spo2_percentage: number | null
          temperature_celsius: number | null
          timestamp_iso: string
          timestamp_unix_ms: number
        }
        Insert: {
          attempt_no?: number | null
          context_type?: string | null
          created_at?: string
          device_sn?: string | null
          eda_scl_usiemens?: number | null
          id?: number
          import_batch_id?: string | null
          participant_full_id: string
          patient_id?: string | null
          prv_rmssd_ms?: number | null
          pulse_rate_bpm?: number | null
          respiratory_rate_brpm?: number | null
          session_id?: string | null
          spo2_percentage?: number | null
          temperature_celsius?: number | null
          timestamp_iso: string
          timestamp_unix_ms: number
        }
        Update: {
          attempt_no?: number | null
          context_type?: string | null
          created_at?: string
          device_sn?: string | null
          eda_scl_usiemens?: number | null
          id?: number
          import_batch_id?: string | null
          participant_full_id?: string
          patient_id?: string | null
          prv_rmssd_ms?: number | null
          pulse_rate_bpm?: number | null
          respiratory_rate_brpm?: number | null
          session_id?: string | null
          spo2_percentage?: number | null
          temperature_celsius?: number | null
          timestamp_iso?: string
          timestamp_unix_ms?: number
        }
        Relationships: []
      }
      ContextIntervals: {
        Row: {
          attempt_no: number | null
          context_type: string
          created_at: string
          end_minute_utc: string
          id: number
          patient_id: string
          session_id: string | null
          start_minute_utc: string
        }
        Insert: {
          attempt_no?: number | null
          context_type: string
          created_at?: string
          end_minute_utc: string
          id?: number
          patient_id: string
          session_id?: string | null
          start_minute_utc: string
        }
        Update: {
          attempt_no?: number | null
          context_type?: string
          created_at?: string
          end_minute_utc?: string
          id?: number
          patient_id?: string
          session_id?: string | null
          start_minute_utc?: string
        }
        Relationships: []
      }
      Patient: {
        Row: {
          birth_date: string
          created_at: string
          email: string
          gender: string
          id: number
          name: string
          phone: string
          surname: string
          user_id: string
          username: string
        }
        Insert: {
          birth_date?: string
          created_at?: string
          email?: string
          gender?: string
          id?: number
          name: string
          phone: string
          surname: string
          user_id: string
          username?: string
        }
        Update: {
          birth_date?: string
          created_at?: string
          email?: string
          gender?: string
          id?: number
          name?: string
          phone?: string
          surname?: string
          user_id?: string
          username?: string
        }
        Relationships: []
      }
      PatientNotifications: {
        Row: {
          content: string
          created_at: string | null
          id: string
          is_read: boolean | null
          patient_id: number | null
          subject: string
        }
        Insert: {
          content: string
          created_at?: string | null
          id?: string
          is_read?: boolean | null
          patient_id?: number | null
          subject: string
        }
        Update: {
          content?: string
          created_at?: string | null
          id?: string
          is_read?: boolean | null
          patient_id?: number | null
          subject?: string
        }
        Relationships: [
          {
            foreignKeyName: "patientnotifications_patient_id_fkey"
            columns: ["patient_id"]
            isOneToOne: false
            referencedRelation: "Patient"
            referencedColumns: ["id"]
          },
        ]
      }
      PatientSession: {
        Row: {
          assigned_date: string
          completed_date: string | null
          created_at: string
          id: number
          patient_id: number
          post_evaluation: number | null
          pre_evaluation: number | null
          resume_at: number | null
          session_id: number
          state: string
        }
        Insert: {
          assigned_date: string
          completed_date?: string | null
          created_at?: string
          id?: number
          patient_id: number
          post_evaluation?: number | null
          pre_evaluation?: number | null
          resume_at?: number | null
          session_id: number
          state?: string
        }
        Update: {
          assigned_date?: string
          completed_date?: string | null
          created_at?: string
          id?: number
          patient_id?: number
          post_evaluation?: number | null
          pre_evaluation?: number | null
          resume_at?: number | null
          session_id?: number
          state?: string
        }
        Relationships: [
          {
            foreignKeyName: "PatientSession_patient_id_fkey"
            columns: ["patient_id"]
            isOneToOne: false
            referencedRelation: "Patient"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "PatientSession_session_id_fkey"
            columns: ["session_id"]
            isOneToOne: false
            referencedRelation: "Session"
            referencedColumns: ["id"]
          },
        ]
      }
      Question: {
        Row: {
          id: number
        }
        Insert: {
          id: number
        }
        Update: {
          id?: number
        }
        Relationships: []
      }
      SecurityLogs: {
        Row: {
          created_at: string | null
          endpoint: string
          id: string
          ip_address: string | null
          user_agent: string | null
          user_id: string | null
        }
        Insert: {
          created_at?: string | null
          endpoint: string
          id?: string
          ip_address?: string | null
          user_agent?: string | null
          user_id?: string | null
        }
        Update: {
          created_at?: string | null
          endpoint?: string
          id?: string
          ip_address?: string | null
          user_agent?: string | null
          user_id?: string | null
        }
        Relationships: []
      }
      Session: {
        Row: {
          created_at: string
          day_offset: number
          duration: number | null
          id: number
          number: number
          source: string | null
        }
        Insert: {
          created_at?: string
          day_offset?: number
          duration?: number | null
          id?: number
          number: number
          source?: string | null
        }
        Update: {
          created_at?: string
          day_offset?: number
          duration?: number | null
          id?: number
          number?: number
          source?: string | null
        }
        Relationships: []
      }
      Survey: {
        Row: {
          completed_date: string
          evaluation: number
          id: number
          patient_id: number
          question_id: number
        }
        Insert: {
          completed_date: string
          evaluation: number
          id?: number
          patient_id: number
          question_id: number
        }
        Update: {
          completed_date?: string
          evaluation?: number
          id?: number
          patient_id?: number
          question_id?: number
        }
        Relationships: [
          {
            foreignKeyName: "Survey_patient_id_fkey"
            columns: ["patient_id"]
            isOneToOne: false
            referencedRelation: "Patient"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "Survey_question_id_fkey"
            columns: ["question_id"]
            isOneToOne: false
            referencedRelation: "Question"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      is_professional: { Args: never; Returns: boolean }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {},
  },
} as const
</file>

<file path="src/identity/domain/interfaces/repositories/UserRepository.ts">
import { UserId } from "@common/domain/model/UserParameters";

export interface UserRepository {
    isProfessional(userId: UserId): Promise<boolean>;
    isPatient(userId: UserId): Promise<boolean>;
}
</file>

<file path="src/identity/infrastructure/http/verifyUser.ts">
import { FastifyReply, FastifyRequest } from 'fastify';
import { UserRepository } from '../../domain/interfaces/repositories/UserRepository';

export const verifyProfessional = (userRepository: UserRepository) => {
    return async (request: FastifyRequest, reply: FastifyReply) => {
        const userId = (request.user as { id?: string } | undefined)?.id;
        if (!userId) {
            return reply.status(401).send({ error: 'Unauthorized' });
        }
        const isProp = await userRepository.isProfessional(userId);
        if (!isProp) {
            return reply.status(403).send({
                error: 'Only professionals can access this resource'
            });
        }
    };
};

export const verifyPatient = (userRepository: UserRepository) => {
    return async (request: FastifyRequest, reply: FastifyReply) => {
        const userId = (request.user as { id?: string } | undefined)?.id;
        if (!userId) {
            return reply.status(401).send({ error: 'Unauthorized' });
        }
        const isPatient = await userRepository.isPatient(userId);
        if (!isPatient) {
            return reply.status(403).send({
                error: 'Only patients can access this resource'
            });
        }
    };
};
</file>

<file path="src/messaging/application/SendToPatient.ts">
import { PatientContactRepository } from "../domain/interfaces/PatientContactRepository";
import { MailRepository } from "../domain/interfaces/MailRepository";
import { NotificationRepository } from "../domain/interfaces/NotificationRepository";

export interface SendToPatientInput {
    patientId: number;
    subject: string;
    body: string;
}

export class SendToPatient {
    constructor(
        private readonly patientContactRepo: PatientContactRepository,
        private readonly mailRepo: MailRepository,
        private readonly notificationRepo: NotificationRepository
    ) {
    }

    async execute(input: SendToPatientInput): Promise<boolean> {
        const email = await this.patientContactRepo.getEmailByPatientId(input.patientId);
        if (!email) return false;

        await this.notificationRepo.saveNotification(
            input.patientId,
            input.subject,
            input.body
        );

        const pendingCount = await this.notificationRepo.getPendingCount(input.patientId);

        const result = await this.mailRepo.send(
            email,
            input.subject,
            input.body,
            pendingCount
        );

        return result.success;
    }
}
</file>

<file path="src/messaging/domain/interfaces/MailRepository.ts">
export interface MailRepository {
    send(
        to: string,
        subject: string,
        body: string,
        pendingCount?: number,
        stats?: any,
        imageBuffer?: Buffer
    ): Promise<any>;
}
</file>

<file path="src/messaging/infrastructure/database/__tests__/SupabaseStatsRepository.test.ts">
import { SupabaseStatsRepository } from '../SupabaseStatsRepository';
import { supabaseClient } from '@common/infrastructure/database/supabaseClient';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';

describe('SupabaseStatsRepository', () => {
    const repository = new SupabaseStatsRepository(supabaseClient);

    beforeAll(async () => {
        await initTestDatabase();
    });

    it('should fetch all patients stats and include session data', async () => {
        const result = await repository.getAllPatientsStats();

        expect(result.length).toBeGreaterThan(0);
        expect(result[0]).toHaveProperty('email', 'benat@test.com');
        expect(result[0]).toHaveProperty('sessions');
        expect(Array.isArray(result[0].sessions)).toBe(true);
    });

    it('should return an array even if the database is empty', async () => {
        await supabaseClient.from('PatientSession').delete().neq('id', 0);
        await supabaseClient.from('Patient').delete().neq('id', 0);

        const result = await repository.getAllPatientsStats();

        expect(Array.isArray(result)).toBe(true);
    });

    it('should map the session states correctly to the patient object', async () => {
        await initTestDatabase();
        const result = await repository.getAllPatientsStats();
        const patient = result.find(p => p.email === 'benat@test.com');

        expect(patient).toBeDefined();
        expect(patient?.sessions?.length).toBeGreaterThan(0);
        expect(patient?.sessions?.[0]).toHaveProperty('state');
    });
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM"],
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": ".",
    "paths": {
      "@src/*": ["src/*", "dist/*"],
      "@common/*": ["src/common/*", "dist/common/*"],
      "@auth/*": ["src/auth/*", "dist/auth/*"],
      "@user/*": ["src/user/*", "dist/user/*"]
    },
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node", "jest"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/common/infrastructure/server/index.ts">
import dotenv from 'dotenv';
dotenv.config();

import { build, start } from './serverBuild';

const fastify = build();
const PORT = Number(process.env.PORT) || 3000;

start(fastify, PORT);
</file>

<file path="src/messaging/infrastructure/endpoints/__tests__/sendWeeklyStats.test.ts">
import { build } from '@common/infrastructure/server/serverBuild';
import { initTestDatabase } from '@common/infrastructure/database/initTestDatabase';

jest.mock('@src/messaging/infrastructure/gmail/GmailApiMailRepository', () => ({
    GmailApiMailRepository: jest.fn().mockImplementation(() => ({
        send: jest.fn().mockResolvedValue({ success: true })
    }))
}));

describe('POST /messaging/send-weekly-stats', () => {
    let app: any;
    const CRON_KEY = 'test-cron-secret';

    beforeAll(async () => {
        process.env.CRON_SECRET_KEY = CRON_KEY;
        app = build();
        await app.ready();
    });

    afterAll(async () => {
        await app.close();
    });

    it('should return 200 and process 0 patients if database is empty', async () => {
        const { supabaseClient } = require('@common/infrastructure/database/supabaseClient');
        await supabaseClient.from('PatientSession').delete().neq('id', 0);
        await supabaseClient.from('Patient').delete().neq('id', 0);

        const response = await app.inject({
            method: 'POST',
            url: '/messaging/send-weekly-stats',
            headers: { 'x-health-insight-cron': CRON_KEY }
        });

        expect(response.statusCode).toBe(200);
        expect(response.json().processed).toBe(0);
    });
});
</file>

<file path="tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@src/*": ["src/*"],
      "@common/*": ["src/common/*"],
      "@auth/*": ["src/auth/*"],
      "@user/*": ["src/user/*"]
    }
  },
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts",
    "**/*.spec.ts",
    "**/__tests__/**"
  ]
}
</file>

<file path="src/common/infrastructure/server/serverBuild.ts">
import Fastify, { FastifyInstance } from 'fastify';
import swagger from '@fastify/swagger';
import swaggerUI from '@fastify/swagger-ui';
import jwt from '@fastify/jwt';
import { registerRoutes } from '../endpoints/routes';
import { securityLogger } from './securityLogger';

export function build(): FastifyInstance {
    const isDev = process.env.NODE_ENV === 'development' || !process.env.NODE_ENV;

    const app = Fastify({
        trustProxy: true,
        logger: {
            transport: isDev ? { target: 'pino-pretty' } : undefined
        }
    });

    app.register(jwt, {
        secret: process.env.SUPABASE_JWT_SECRET || 'super-secret-key'
    });

    registerSwagger(app);
    registerSwaggerUI(app);

    if (process.env.NODE_ENV !== 'test') {
        app.addHook('preHandler', securityLogger);
    }

    registerRoutes(app);

    return app;
}

function registerSwagger(app: FastifyInstance) {
    app.register(swagger, {
        openapi: {
            info: {
                title: 'HealthInsight API',
                description: 'API de Telerehabilitación con análisis de mareo',
                version: '1.0.0',
            },
        },
    });
}

function registerSwaggerUI(app: FastifyInstance) {
    app.register(swaggerUI, {
        routePrefix: '/docs',
    });
}

export const start = async (fastify: FastifyInstance, PORT: number): Promise<void> => {
    try {
        await fastify.listen({ port: PORT, host: '0.0.0.0' });
        console.log(`\n SERVIDOR ACTIVO`);
        console.log(`\tPuerto: ${PORT}`);
        console.log(`\tEntorno: ${process.env.NODE_ENV || 'development'}`);
        console.log(`\tDocumentación: http://0.0.0.0:${PORT}/docs\n`);
    } catch (err: any) {
        console.error(' ❌ Error crítico al arrancar:', err);
        fastify.log.error(err);
        process.exit(1);
    }
};
</file>

<file path="src/messaging/application/__tests__/SendWeeklyStats.spec.ts">
import { SendWeeklyStats } from '../SendWeeklyStats';

describe('SendWeeklyStats Service', () => {
    const mockStatsRepo = { getAllPatientsStats: jest.fn() };
    const mockMailRepo = { send: jest.fn() };
    const mockNotificationRepo = {
        saveNotification: jest.fn(),
        getPendingCount: jest.fn()
    };

    const service = new SendWeeklyStats(
        mockStatsRepo as any,
        mockMailRepo as any,
        mockNotificationRepo as any
    );

    it('should execute successfully and send email with stats', async () => {
        const mockStats = [{
            id: 1,
            email: 'p1@t.com',
            sessions: [{ state: 'completed' }]
        }];

        mockStatsRepo.getAllPatientsStats.mockResolvedValue(mockStats);
        mockNotificationRepo.getPendingCount.mockResolvedValue(1);
        mockMailRepo.send.mockResolvedValue({ success: true });

        await service.execute();

        expect(mockNotificationRepo.saveNotification).toHaveBeenCalled();
        expect(mockMailRepo.send).toHaveBeenCalled();
    });
});
</file>

<file path="src/messaging/infrastructure/endpoints/sendToPatient.ts">
import { FastifyInstance } from 'fastify';
import { SendToPatient } from '../../application/SendToPatient';

export default function sendToPatient(deps: any) {
    return async function (fastify: FastifyInstance) {
        fastify.post('/messaging/send-to-patient', async (request, reply) => {
            try {
                const { patientId, subject, body } = request.body as any;
                const service = new SendToPatient(deps.patientContactRepo, deps.mailRepo, deps.notificationRepo);

                const success = await service.execute({ patientId, subject, body });

                if (!success) {
                    return reply.status(404).send({ status: 'error', message: 'No se encontró contacto' });
                }

                return { status: 'success', message: 'Mensaje guardado y notificación enviada correctamente' };
            } catch (error) {
                fastify.log.error(error);
                return reply.status(500).send({ status: 'error', message: 'Error interno' });
            }
        });
    };
}
</file>

<file path="src/messaging/infrastructure/endpoints/sendWeeklyStats.ts">
import { FastifyReply, FastifyRequest } from 'fastify';
import { SendWeeklyStats } from '../../application/SendWeeklyStats';

export default function sendWeeklyStats(deps: any) {
    return async function (request: FastifyRequest, reply: FastifyReply) {
        const cronSecret = request.headers['x-health-insight-cron'];
        const isCron = cronSecret === process.env.CRON_SECRET_KEY;
        const isProfessional = (request as any).user?.role === 'professional';

        if (!isCron && !isProfessional) {
            return reply.status(403).send({
                status: 'error',
                message: 'Acceso denegado'
            });
        }

        try {
            const service = new SendWeeklyStats(
                deps.statsRepo,
                deps.mailRepo,
                deps.notificationRepo
            );

            const totalProcessed = await service.execute();

            return reply.status(200).send({
                status: 'success',
                processed: totalProcessed
            });
        } catch (error) {
            request.log.error(error);
            return reply.status(500).send({
                status: 'error',
                message: 'Error en el proceso masivo'
            });
        }
    };
}
</file>

<file path="src/messaging/infrastructure/gmail/GmailApiMailRepository.ts">
import { google } from 'googleapis';
import { MailRepository } from '../../domain/interfaces/MailRepository';
import { HtmlImageGenerator } from '../images/HtmlImageGenerator';

export class GmailApiMailRepository implements MailRepository {
    private oauth2Client;
    private imageGenerator: HtmlImageGenerator;

    constructor() {
        this.oauth2Client = new google.auth.OAuth2(
            process.env.GMAIL_CLIENT_ID,
            process.env.GMAIL_CLIENT_SECRET,
            "https://developers.google.com/oauthplayground"
        );
        this.oauth2Client.setCredentials({
            refresh_token: process.env.GMAIL_REFRESH_TOKEN
        });
        this.imageGenerator = new HtmlImageGenerator();
    }

    private getMasterLayout(content: string): string {
        return `
        <!DOCTYPE html>
        <html lang="es">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="margin: 0; padding: 0; background-color: #f4f7f9; font-family: 'Segoe UI', Helvetica, Arial, sans-serif;">
            <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0">
                <tr>
                    <td align="center" style="padding: 40px 10px;">
                        <table role="presentation" width="100%" style="max-width: 600px; background-color: #ffffff; border-radius: 16px; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.08);">
                            <tr>
                                <td style="background: linear-gradient(135deg, #1a2a6c, #2a4858); padding: 40px 20px; text-align: center;">
                                    <h1 style="color: #ffffff; margin: 0; font-size: 26px; font-weight: 300; letter-spacing: 3px; text-transform: uppercase;">Health Insight</h1>
                                </td>
                            </tr>
                            <tr>
                                <td style="padding: 45px 35px; color: #334155;">
                                    ${content}
                                </td>
                            </tr>
                            <tr>
                                <td style="background-color: #f8fafc; padding: 25px; text-align: center; border-top: 1px solid #e2e8f0;">
                                    <p style="font-size: 12px; color: #94a3b8; margin: 0;"><strong>Health Insight API</strong> | Centro de Telerehabilitación</p>
                                    <p style="font-size: 10px; color: #cbd5e1; margin-top: 15px; line-height: 1.4;">Este es un mensaje automático, por favor no responda a este correo.</p>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </body>
        </html>`;
    }

    private getNotificationContent(pendingCount: number): string {
        const countText = pendingCount > 1
            ? `Tienes ${pendingCount} mensajes nuevos sin leer`
            : `Tienes 1 mensaje nuevo sin leer`;

        return `
        <div style="text-align: center;">
            <h2 style="color: #1a2a6c; font-size: 22px; margin-top: 0; margin-bottom: 30px;">Nueva actividad en tu panel</h2>
            
            <div style="background-color: #f1f5f9; border-left: 4px solid #1a2a6c; padding: 25px; border-radius: 4px; margin: 30px 0;">
                <span style="display: block; color: #1e40af; font-size: 20px; font-weight: 600;">
                    ${countText}
                </span>
            </div>

            <p style="color: #64748b; font-size: 15px; line-height: 1.6; margin-bottom: 35px;">
                Tu especialista ha actualizado tu seguimiento. Accede a la plataforma para revisar los nuevos mensajes.
            </p>

            <a href="https://digital-therapy-platform.web.app" 
               style="background: linear-gradient(to bottom, #10b981 0%, #059669 100%); color: #ffffff; padding: 18px 36px; text-decoration: none; border-radius: 50px; font-weight: 700; display: inline-block; font-size: 14px; letter-spacing: 1px; border-bottom: 4px solid #047857; box-shadow: 0 4px 0 #047857, 0 8px 15px rgba(0, 0, 0, 0.15);">
               ACCEDER A MIS MENSAJES
            </a>
        </div>`;
    }

    private getStatsHtml(stats: any): string {
        const total = (stats.completed + stats.inProgress + stats.notStarted) || 1;
        const progress = Math.round((stats.completed / total) * 100);

        return `
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="margin-bottom: 20px;">
                <img src="cid:weekly-donut" width="300" alt="Tu Evolución" style="display: block; margin: 0 auto; max-width: 100%;">
            </div>
            <h2 style="color: #1a2a6c; font-size: 22px; margin-bottom: 10px;">Tu Progreso Semanal</h2>
            <p style="color: #64748b; margin: 0;">Has completado el <strong>${progress}%</strong> de tus objetivos.</p>
        </div>
        
        <table role="presentation" width="100%" cellspacing="0" cellpadding="0" border="0" style="background-color: #f8fafc; border-radius: 12px; margin-bottom: 35px;">
            <tr>
                <td align="center" style="padding: 25px; border-right: 1px solid #e2e8f0;">
                    <span style="display: block; font-size: 28px; font-weight: bold; color: #10b981;">${stats.completed}</span>
                    <span style="font-size: 11px; color: #94a3b8; text-transform: uppercase;">Hechas</span>
                </td>
                <td align="center" style="padding: 25px; border-right: 1px solid #e2e8f0;">
                    <span style="display: block; font-size: 28px; font-weight: bold; color: #f59e0b;">${stats.inProgress}</span>
                    <span style="font-size: 11px; color: #94a3b8; text-transform: uppercase;">En curso</span>
                </td>
                <td align="center" style="padding: 25px;">
                    <span style="display: block; font-size: 28px; font-weight: bold; color: #ef4444;">${stats.notStarted}</span>
                    <span style="font-size: 11px; color: #94a3b8; text-transform: uppercase;">Pendientes</span>
                </td>
            </tr>
        </table>

        <div style="text-align: center;">
            <a href="https://digital-therapy-platform.web.app/dashboard" 
               style="background: linear-gradient(to bottom, #10b981 0%, #059669 100%); color: #ffffff; padding: 16px 32px; text-decoration: none; border-radius: 50px; font-weight: 700; display: inline-block; font-size: 14px; border-bottom: 4px solid #047857; box-shadow: 0 4px 0 #047857, 0 8px 15px rgba(0, 0, 0, 0.15);">
               VER PANEL DETALLADO
            </a>
        </div>`;
    }

    async send(to: string, subject: string, body: string, pendingCount: number = 1, stats?: any): Promise<{ success: boolean }> {
        const gmail = google.gmail({ version: 'v1', auth: this.oauth2Client });

        const mainContent = stats
            ? this.getStatsHtml(stats)
            : this.getNotificationContent(pendingCount);

        const htmlContent = this.getMasterLayout(mainContent);
        const boundary = "__HEALTH_INSIGHT_BOUNDARY__";
        const utf8Subject = `=?utf-8?B?${Buffer.from(subject).toString('base64')}?=`;

        let message = [
            `To: ${to}`,
            `Subject: ${utf8Subject}`,
            `MIME-Version: 1.0`,
            `Content-Type: multipart/related; boundary="${boundary}"`,
            '',
            `--${boundary}`,
            'Content-Type: text/html; charset=utf-8',
            '',
            htmlContent,
            ''
        ].join('\r\n');

        if (stats) {
            const imageBuffer = await this.imageGenerator.generateWeeklyDashboard(stats);
            message += [
                `--${boundary}`,
                'Content-Type: image/png',
                'Content-Transfer-Encoding: base64',
                'Content-ID: <weekly-donut>',
                'Content-Disposition: inline; filename="stats.png"',
                '',
                imageBuffer.toString('base64'),
                ''
            ].join('\r\n');
        }

        message += `--${boundary}--`;
        const raw = Buffer.from(message).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

        try {
            await gmail.users.messages.send({ userId: 'me', requestBody: { raw } });
            return { success: true };
        } catch (error) {
            console.error('Gmail API Send Error:', error);
            return { success: false };
        }
    }
}
</file>

<file path="src/messaging/infrastructure/images/HtmlImageGenerator.ts">
import nodeHtmlToImage from "node-html-to-image";
import fs from 'fs';

export class HtmlImageGenerator {
    async generateWeeklyDashboard(stats: any): Promise<Buffer> {
        const total = (stats.completed + stats.inProgress + stats.notStarted) || 1;
        const completedPct = Math.round((stats.completed / total) * 100);
        const inProgressPct = Math.round((stats.inProgress / total) * 100);
        const inProgressEnd = completedPct + inProgressPct;

        const isPerfect = completedPct === 100;
        const statusLabel = isPerfect ? "¡Objetivo Cumplido!" : "Progreso de Adherencia";
        const progressColor = isPerfect ? "#f59e0b" : "#10b981";
        const labelColor = isPerfect ? "#f59e0b" : "#1a2a6c";

        const chromePath = '/usr/bin/google-chrome-stable';
        const executablePath = (process.env.NODE_ENV === 'production' && fs.existsSync(chromePath))
            ? chromePath
            : undefined;

        return await nodeHtmlToImage({
            transparent: true,
            puppeteerArgs: {
                executablePath,
                args: [
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-gpu'
                ]
            },
            html: `
      <html>
        <head>
          <style>
            body { width: 500px; height: 400px; font-family: sans-serif; background: #ffffff; display: flex; justify-content: center; align-items: center; margin: 0; }
            .chart-container { text-align: center; padding: 20px; }
            .donut-chart {
              width: 180px; height: 180px; border-radius: 50%;
              background: conic-gradient(${progressColor} 0% ${completedPct}%, #f59e0b ${completedPct}% ${inProgressEnd}%, #e2e8f0 ${inProgressEnd}% 100%);
              display: flex; align-items: center; justify-content: center; margin: 0 auto 30px auto;
            }
            .donut-inner { width: 135px; height: 135px; background: #ffffff; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
            .pct-main-text { font-size: 52px; font-weight: bold; color: ${labelColor}; }
            .status-badge { font-size: 34px; font-weight: 800; color: ${labelColor}; }
          </style>
        </head>
        <body>
          <div class="chart-container">
            <div class="donut-chart"><div class="donut-inner"><span class="pct-main-text">${completedPct}%</span></div></div>
            <span class="status-badge">${statusLabel}</span>
          </div>
        </body>
      </html>`
        }) as Buffer;
    }
}
</file>

<file path="src/messaging/application/SendWeeklyStats.ts">
import { MailRepository } from "../domain/interfaces/MailRepository";
import { NotificationRepository } from "../domain/interfaces/NotificationRepository";
import { StatsRepository } from "../domain/interfaces/StatsRepository";

export class SendWeeklyStats {
    constructor(
        private readonly statsRepo: StatsRepository,
        private readonly mailRepo: MailRepository,
        private readonly notificationRepo: NotificationRepository
    ) {}

    async execute(): Promise<number> {
        const patientsData = await this.statsRepo.getAllPatientsStats();
        let count = 0;

        for (const patient of patientsData) {
            patient.completed = 0;
            patient.inProgress = 0;
            patient.notStarted = 0;

            patient.sessions?.forEach(s => {
                if (s.state === 'completed') patient.completed++;
                else if (s.state === 'in_progress') patient.inProgress++;
                else if (s.state === 'not_started') patient.notStarted++;
            });

            if (patient.id) {
                const pendingCount = await this.notificationRepo.getPendingCount(patient.id);

                await this.mailRepo.send(
                    patient.email,
                    "Tu resumen semanal de salud",
                    "",
                    pendingCount,
                    patient
                );

                count++;
            }
        }
        return count;
    }
}
</file>

<file path="Dockerfile">
FROM node:20-slim

RUN apt-get update && apt-get install -y \
    wget \
    gnupg \
    ca-certificates \
    apt-transport-https \
    && wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - \
    && sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list' \
    && apt-get update \
    && apt-get install -y google-chrome-stable --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /usr/src/app

COPY package*.json ./

ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
RUN npm install

COPY . .
RUN npm run build

EXPOSE 3000

ENV NODE_ENV=production

CMD [ "npm", "start" ]
</file>

<file path="package.json">
{
  "name": "health-insight-api",
  "version": "1.0.0",
  "description": "Backend modular para telerehabilitación",
  "main": "dist/common/infrastructure/server/index.js",
  "type": "commonjs",
  "scripts": {
    "dev": "nodemon --ext ts --watch src --exec \"ts-node -r dotenv/config -r tsconfig-paths/register src/common/infrastructure/server/index.ts\"",
    "build": "tsc --project tsconfig.build.json && tsc-alias -p tsconfig.build.json",
    "start": "NODE_ENV=production node dist/common/infrastructure/server/index.js",
    "test": "cross-env NODE_ENV=test jest --runInBand --detectOpenHandles"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.968.0",
    "@fastify/jwt": "^10.0.0",
    "@fastify/swagger": "^9.5.1",
    "@fastify/swagger-ui": "^5.2.3",
    "@supabase/supabase-js": "^2.48.0",
    "axios": "^1.6.0",
    "csv-parse": "^6.1.0",
    "dotenv": "^16.4.0",
    "fastify": "^5.0.0",
    "fastify-plugin": "^5.0.1",
    "googleapis": "^128.0.0",
    "kysely": "^0.27.0",
    "node-html-to-image": "^5.0.0",
    "nodemailer": "^7.0.12",
    "pg": "^8.11.0",
    "pino-pretty": "^11.0.0",
    "tsconfig-paths": "^4.2.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.0",
    "@types/node": "^20.19.29",
    "@types/nodemailer": "^7.0.5",
    "@types/pg": "^8.11.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "cross-env": "^7.0.3",
    "eslint": "^8.57.0",
    "husky": "^9.0.0",
    "jest": "^29.7.0",
    "nodemon": "^3.1.0",
    "prettier": "^3.2.0",
    "ts-jest": "^29.4.6",
    "ts-node": "^10.9.2",
    "tsc-alias": "^1.8.16",
    "typescript": "^5.4.0"
  }
}
</file>

<file path="src/common/infrastructure/endpoints/routes.ts">
import { FastifyInstance } from 'fastify';
import { supabaseClient } from '../database/supabaseClient';
import { authenticate } from '@src/identity/infrastructure/http/authenticate';
import { SupabaseUserRepository } from '@src/identity/infrastructure/database/repositories/SupabaseUserRepository';
import { verifyProfessional, verifyPatient } from '@src/identity/infrastructure/http/verifyUser';
import presenceMinute from '@src/biometrics/infrastructure/endpoints/presenceMinute';
import syncDailyBiometrics from '@src/biometrics/infrastructure/endpoints/syncDailyBiometrics';
import getSessionReport from '@src/biometrics/infrastructure/endpoints/getSessionReport';
import predictDropout from '@src/clinical-intelligence/infrastructure/endpoints/predictDropout';
import sendToPatient from '@src/messaging/infrastructure/endpoints/sendToPatient';
import sendWeeklyStats from '@src/messaging/infrastructure/endpoints/sendWeeklyStats';
import patientNotifications from '@src/messaging/infrastructure/endpoints/patientNotifications';
import { SupabaseDropoutRepository } from '@src/clinical-intelligence/infrastructure/database/SupabaseDropoutRepository';
import { SupabasePatientContactRepository } from '@src/messaging/infrastructure/database/SupabasePatientContactRepository';
import { SupabaseStatsRepository } from '@src/messaging/infrastructure/database/SupabaseStatsRepository';
import { SupabaseNotificationRepository } from '@src/messaging/infrastructure/database/SupabaseNotificationRepository';
import { GmailApiMailRepository } from "@src/messaging/infrastructure/gmail/GmailApiMailRepository";

export function registerRoutes(fastify: FastifyInstance) {
    const userRepo = new SupabaseUserRepository(supabaseClient);
    const dropoutRepo = new SupabaseDropoutRepository(supabaseClient as any);
    const statsRepo = new SupabaseStatsRepository(supabaseClient);
    const patientContactRepo = new SupabasePatientContactRepository(supabaseClient);
    const notificationRepo = new SupabaseNotificationRepository(supabaseClient);
    const mailRepo = new GmailApiMailRepository();
    const deps = { statsRepo, mailRepo, notificationRepo, patientContactRepo, dropoutRepo };

    fastify.get('/ping', async () => ({ status: 'ok' }));

    fastify.post('/biometrics/sync-daily', syncDailyBiometrics());
    fastify.get('/biometrics/sync-daily', syncDailyBiometrics());

    fastify.register(presenceMinute());

    fastify.register(async (app) => {
        app.post('/messaging/send-weekly-stats', sendWeeklyStats(deps));

        app.register(async (authenticatedApp) => {
            // authenticatedApp.addHook('preHandler', authenticate);

            authenticatedApp.register(async (professionalApp) => {
                // professionalApp.addHook('preHandler', verifyProfessional(userRepo));
                professionalApp.register(predictDropout({ dropoutRepo }));
                professionalApp.register(sendToPatient(deps));
                professionalApp.register(getSessionReport());
            });

            authenticatedApp.register(async (patientApp) => {
                // patientApp.addHook('preHandler', verifyPatient(userRepo));
                patientApp.register(patientNotifications({ notificationRepo }));
            });
        });
    });
}
</file>

</files>
